<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Dagger 2 - User's Guide 翻译]]></title>
      <url>smineyeung.github.io/2016/05/18/Dagger_2_User_s_Guide/</url>
      <content type="html"><![CDATA[<p>在程序中， 最重要的类是那些真正实现功能的类：<code>BarcodeDecoder</code>, <code>KoopaPhysicsEngine</code> 和 <code>AudioStreamer</code>. 这些类都会依赖于其他的类; 可能是 <code>BarcodeCameraFinder</code>, <code>DefaultPhysicsEngine</code>, 和 <code>HttpStreamer</code>.</p>
<p>相对来说，程序中最不重要的类是辅助类: <code>BarcodeDecoderFactory</code>, <code>CameraServiceLoader</code>, <code>MutableContextWrapper</code>. 这些辅助类就像笨拙的胶带一样，将那些重要的功能类连接起来.（实际上就是讲需要用到依赖注入的地方需要编写大量重复的工厂类代码）</p>
<p>Dagger 就是在实现 <a href="http://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="external">dependency injection</a> 的设计模式的时候用来替代累赘的工厂类代码，让你专注于编写那些重要的功能类上. 声明依赖，指定如何满足依赖，然后运行你的应用即可.</p>
<p>Dagger 构建在标准的  <a href="http://docs.oracle.com/javaee/7/api/javax/inject/package-summary.html" target="_blank" rel="external">javax.inject</a>  注解 (<a href="https://jcp.org/en/jsr/detail?id=330" target="_blank" rel="external">JSR 330</a>) 基础上，每个类都会变得<strong>很容易测试</strong>。你不需要为了便于将 <code>RpcCreditCardService</code>  替换掉 <code>FakeCreditCardService</code> 而编写一大堆重复的代码.</p>
<p>依赖注入不仅仅是为了测试. 它也可以很容易地创建<strong>可重用的，易替换的模块</strong>. 在整个应用程序中， 你可以共享同一个的 <code>AuthenticationModule</code>(认证模块) . 你也可以在开发版本中使用 <code>DevLoggingModule</code> 以及在发布版本中使用 <code>ProdLoggingModule</code>，从而针对不同的情况来做不同的行为测试.</p>
<h2 id="为什么-Dagger-2-是不一样的-Why-Dagger-2-is-Different"><a href="#为什么-Dagger-2-是不一样的-Why-Dagger-2-is-Different" class="headerlink" title="为什么 Dagger 2 是不一样的 (Why Dagger 2 is Different)"></a>为什么 Dagger 2 是不一样的 (Why Dagger 2 is Different)</h2><p>依赖注入框架已经存在多年了，并且提供了完整的用于配置和注入的各种接口. 所以，为什么还要重新发明轮子呢？ Dagger 2 是第一个完全用自动生成的代码来实现的（即没有用到反射）. 基本的思想就是自动生成的代码就像开发者自己手写一样，让依赖注入变得更简单，可溯源以及提高性能. 想要了解更多 Dagger 2 的设计背景，请观看 <a href="https://google.com/+GregoryKick/" target="_blank" rel="external">Gregory Kick</a> 的<a href="https://youtu.be/oK_XtfXPkqw" target="_blank" rel="external">演讲视频</a>和<a href="https://docs.google.com/presentation/d/1fby5VeGU9CN8zjw4lAb2QPPsKRxx6mSwCe9q7ECNSJQ/pub?start=false&amp;loop=false&amp;delayms=3000" target="_blank" rel="external">演讲用到的幻灯片</a>.</p>
<h2 id="Dagger-的用法-Using-Dagger"><a href="#Dagger-的用法-Using-Dagger" class="headerlink" title="Dagger 的用法 (Using Dagger)"></a>Dagger 的用法 (Using Dagger)</h2><p>我们将通过一个煮咖啡的例子来演示依赖注入和 Dagger 的用法. 你可以编译和运行完成的示例代码，请查看 Dagger 的 <a href="https://github.com/google/dagger/tree/master/examples/simple/src/main/java/coffee" target="_blank" rel="external">coffee example</a>.</p>
<h3 id="声明依赖关系-Declaring-Dependencies"><a href="#声明依赖关系-Declaring-Dependencies" class="headerlink" title="声明依赖关系 (Declaring Dependencies)"></a>声明依赖关系 (Declaring Dependencies)</h3><p>Dagger 为你应用程序中的类构造实例并完成依赖注入. 使用 <a href="http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html" target="_blank" rel="external">javax.inject.Inject</a> 注解来确定需要注入的构造方法和域.</p>
<p>使用 @Inject 去注解一个构造方法，Dagger 就会使用这个构造方法来创建该类的实例.当需要注入这个类的实例的时候，Dagger会提供生成这个类的实例所需要的参数并调用构造方法生成这个实例，完成注入.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thermosiphon</span> <span class="keyword">implements</span> <span class="title">Pump</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Heater heater;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  Thermosiphon(Heater heater) &#123;</span><br><span class="line">    <span class="keyword">this</span>.heater = heater;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dagger 可以直接注入域。在这个例子中，Dagger 会获取自动生成的 Heater 和 Pump 的实例分别用于 heater 和 pump 域的注入.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMaker</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> Heater heater;</span><br><span class="line">  <span class="meta">@Inject</span> Pump pump;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你只使用 @inject 注入域而没有使用 @inject 注入到所需要的构造方法，当请求注入域的时候，Dagger 会注入这个域但不会创建一个该域所需要的新的实例。使用 @Inject 注解去标注一个无参数的构造方法时，Dagger 也可以创建一个新的实例.</p>
<p>虽然我们经常使用构造方法或域的注入，但 Dagger 也支持方法的注入.</p>
<p>类如果缺少 @Inject 注解就不能被 Dagger 自动生成实例.</p>
<h3 id="实现依赖关系-Satisfying-Dependencies"><a href="#实现依赖关系-Satisfying-Dependencies" class="headerlink" title="实现依赖关系 (Satisfying Dependencies)"></a>实现依赖关系 (Satisfying Dependencies)</h3><p>默认情况下，如上所述，在需要注入的时候，Dagger 会自动生成一个实例来满足每个依赖。当你需要 <code>CoffeeMaker</code> 实例的时候，它就会通过调用 <code>new CoffeeMaker()</code> 来生成并赋值给 @Inject 标记的域.</p>
<p>但 @Inject 并不适用于任何情况下:</p>
<ul>
<li>接口类型不能被构造</li>
<li>第三方提供的类不能被构造</li>
<li>可配置的对象必须被配置好（猜测意思：应该是注入时所依赖的对象必须被配置好）<code>Configurable objects must be configured!</code></li>
</ul>
<p>对于那些使用 @Inject 不能完全满足或不顺手的时候，可以使用 <a href="http://google.github.io/dagger/api/latest/dagger/Provides.html" target="_blank" rel="external">@Provides</a> 来注解方法实现依赖关系。这些方法的返回类型表明了它要实现的依赖关系.</p>
<p>例如，当需要一个 Heater 对象的时候， Dagger 将调用<code>provideHeater()</code>  方法来获取:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span> <span class="function"><span class="keyword">static</span> Heater <span class="title">provideHeater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ElectricHeater();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被 @Provides 注解的方法也可以依赖于自身。下面的例子中，当需要一个 <code>Pump</code> 实例的时候，会返回一个 <code>Thermosiphon</code> 实例。:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span> <span class="function"><span class="keyword">static</span> Pump <span class="title">providePump</span><span class="params">(Thermosiphon pump)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pump;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的 @Provides 方法必须属于一个 Module 。这些 Module 类使用 <a href="http://google.github.io/dagger/api/latest/dagger/Module.html" target="_blank" rel="external">@Module</a> 注解.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DripCoffeeModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="function"><span class="keyword">static</span> Heater <span class="title">provideHeater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ElectricHeater();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provides</span> <span class="function"><span class="keyword">static</span> Pump <span class="title">providePump</span><span class="params">(Thermosiphon pump)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pump;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常情况下， 约定 @Provides 注解的方法以 <code>provide</code> 作为前缀， @Module 注解的类以 <code>Module</code> 作为后缀.</p>
<h3 id="构建对象图-Building-the-Graph"><a href="#构建对象图-Building-the-Graph" class="headerlink" title="构建对象图 (Building the Graph)"></a>构建对象图 (Building the Graph)</h3><p>@Inject 和 @Provides 注解的类构建了一个对象图。这些对象与对象之间通过依赖关系相互关联. 像在应用程序的 <code>main</code> 方法或 Android 的 <a href="http://developer.android.com/reference/android/app/Application.html" target="_blank" rel="external">Application</a> 中调用的代码，通过 a well-defined set of roots 访问对象图. 在 Dagger 2 中,依赖图是通过定义一个接口实现的，并且这个接口中有一个没有参数并且返回值正是所期望得到的类型的方法. 用 <a href="http://google.github.io/dagger/api/latest/dagger/Component.html" target="_blank" rel="external">@Component</a> 注解接口，然后将 <a href="http://google.github.io/dagger/api/latest/dagger/Module.html" target="_blank" rel="external">module</a> 类型作为 modules 注解元素的值传入进去，Dagger 2 会自动完成接口的实现类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = DripCoffeeModule.class)</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CoffeeShop</span> </span>&#123;</span><br><span class="line">  <span class="function">CoffeeMaker <span class="title">maker</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口的实现类采取同样的命名方式，以 <code>Dagger</code> 作为前缀，即 <code>DaggerXxx</code>，<code>Xxx</code> 是接口的名字. 获得一个新实例，需要通过调用 Dagger 自动生成的接口实现类的 builder() 方法，然后使用  builder() 方法所得到的返回值再通过设置好所需的依赖 Module 对象后，通过 <a href="http://en.wikipedia.org/wiki/Builder_pattern" target="_blank" rel="external">builder</a> 设计模式，执行 build() 方法生成一个新的实例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CoffeeShop coffeeShop = DaggerCoffeeShop.builder()</span><br><span class="line">    .dripCoffeeModule(<span class="keyword">new</span> DripCoffeeModule())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>注意</em>：如果你用 @component  所注释的类不是最外层的类（即内部类），Dagger 自动生成的 component  实现类的命名会包含封装它的类的名字，并用一个下划线连接起来.例如以下代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">BazComponent</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将生成的 component 实现类被命名为 <code>DaggerFoo_Bar_BazComponent</code>.</p>
<p>如果 Module 有默认的构造方法并且使用默认的构造方法创建 Module 对象，则可以不用在 <code>builder()</code> 后添加 <code>.xxxModule(new XxxModule())</code> 方法，Dagger 会创建这个 Module 对象. 并且如果 Module 中的所有被 @Provider 注释的方法都是静态方法，实现类也不需要实例化该 Module。如果所有的依赖关系都无需使用者通过创建依赖实例来构建，被自动生成的实现类只需要执行 <code>create()</code> 方法即可得到一个新的 component 实现类的实例而无需处理 builder.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CoffeeShop coffeeShop = DaggerCoffeeShop.create();</span><br></pre></td></tr></table></figure>
<p>现在，我们的 CoffeeApp 可以简单地是使用 Dagger 生成的 CoffeeShop 实现类（@Component 注释接口的实现类 DaggerCoffeeShop）来获得一个注入好的 CoffeeMaker 了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CoffeeShop coffeeShop = DaggerCoffeeShop.create();</span><br><span class="line">    coffeeShop.maker().brew();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在， 对象图表已经构建好， 根对象也已被注入， 我们就可以运行这个Coffee 程序了…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp ... coffee.CoffeeApp</span><br><span class="line">~ ~ ~ heating ~ ~ ~</span><br><span class="line">=&gt; =&gt; pumping =&gt; =&gt;</span><br><span class="line"> [_]P coffee! [_]P</span><br></pre></td></tr></table></figure>
<h4 id="绑定对象图-Bindings-in-the-graph"><a href="#绑定对象图-Bindings-in-the-graph" class="headerlink" title="绑定对象图 (Bindings in the graph)"></a>绑定对象图 (Bindings in the graph)</h4><p>上面的例子展示了如何通过一些比较常用的绑定来构建一个 component，但是还有各种各样的机制用于绑定对象图的. 以下可用于作为依赖关系也可用来生成一个结构良好的  component:</p>
<ul>
<li>那些被 @Provides 声明的方法里的 @Module 被 @Component 中的 modules 注解元素直接引用或通过 @Module 的 includes 注解元素引用 </li>
<li>任何类型的带有 @Inject 的构造器可以没有 @Scope 标注或者有一个匹配 component 中的一个 scope 的 @Scope 注解标注</li>
<li>The <a href="http://google.github.io/dagger/api/latest/dagger/Component.html#provision-methods" target="_blank" rel="external">component provision methods</a> of the <a href="http://google.github.io/dagger/api/latest/dagger/Component.html#dependencies%28%29" target="_blank" rel="external">component dependencies</a> </li>
<li>The component itself </li>
<li>Unqualified <a href="http://google.github.io/dagger/api/latest/dagger/Subcomponent.Builder.html" target="_blank" rel="external">builders</a> for any included <a href="http://google.github.io/dagger/api/latest/dagger/Subcomponent.html" target="_blank" rel="external">subcomponent</a> </li>
<li>使用 <code>Provider</code> 或 <code>Lazy</code> 包裹以上任何的绑定</li>
<li>A Provider of a Lazy of any of the above bindings (e.g., Provider&lt;Lazy&lt;CoffeeMaker&gt;&gt;)</li>
<li>A <code>MembersInjector</code> for any type</li>
</ul>
<h3 id="单例和作用域注解绑定-Singletons-and-Scoped-Bindings"><a href="#单例和作用域注解绑定-Singletons-and-Scoped-Bindings" class="headerlink" title="单例和作用域注解绑定 (Singletons and Scoped Bindings)"></a>单例和作用域注解绑定 (Singletons and Scoped Bindings)</h3><p>给 @Provides 注解的方法或者可注入的类， 添加 <a href="http://docs.oracle.com/javaee/7/api/javax/inject/Singleton.html" target="_blank" rel="external">@Singlton</a> 注解， 构建的这个对象图将使用唯一的对象实例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span> <span class="meta">@Singleton</span> <span class="function"><span class="keyword">static</span> Heater <span class="title">provideHeater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ElectricHeater();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可注入类的 @Singleton 注解也可以作为 <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Documented.html" target="_blank" rel="external">documentation</a>， 它提示那些潜在的维护者们：多个线程将共享唯一个对象实例.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMaker</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 Dagger 2 将对象图中被作用域注解的实例和 component 实现类的实例关联起来对象图中被作用域注解的实例，components 本身需要声明将要使用哪个作用域注解来表示. 例如，将一个 @Singleton 绑定和一个 @RequestScoped 绑定在同一个 component 是没有任何意义的，因为那些作用域注解拥有不同的生命周期，因此必须绑定在不同生命周期的 components. 要声明一个 component  和一个给定的作用域注解关联，只需要简单地将该作用域注解添加到 component 接口.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = DripCoffeeModule.class)</span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CoffeeShop</span> </span>&#123;</span><br><span class="line">  <span class="function">CoffeeMaker <span class="title">maker</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Components  可以有多个作用域注解被申请. 这表明它们都是同一个作用域注解的别名，因此，component 包括任何该作用域注解的绑定.</p>
<h3 id="可重用的作用域注解-Reusable-scope"><a href="#可重用的作用域注解-Reusable-scope" class="headerlink" title="可重用的作用域注解 (Reusable scope)"></a>可重用的作用域注解 (Reusable scope)</h3><p>有时，你想要限制被 @Inject 创建的类实例化或 @Provides 方法被调用的次数，但你不需要保证在任何特定的 component 或 subcomponent 的生命周期中同样的实例被重用. 在内存紧缺的 Android 开发中特别有用.</p>
<p>你可以提供 <a href="http://google.github.io/dagger/api/latest/dagger/Reusable.html" target="_blank" rel="external">@Reusable</a> 作用域注解实现这些绑定。@Reusable 作用域注解绑定不想其他作用域注解，它不与任何单一的 component 关联; 相反，每个 component  实际上使用它进行绑定将对返回值或实例化的对象进行缓存.</p>
<p>这意味着如果你在 component 中设置一个带有 @Reusable 绑定的 module ，但只有一个 subcomponent  实际上使用到该绑定，那么就只有该 subcomponent 对该绑定对象进行缓存. 如果两个 subcomponent 都不共享每次使用该绑定的 ancestor ，它们将各自对自己的对象进行缓存. 如果 component 的 ancestor 已经缓存了该对象，那么 subcomponent  将重用它.</p>
<p>如果不能保证 component 只调用该绑定一次，那么用@Reusable 绑定所返回的对象是易变的，或者用于返回同一个实例对象都是很危险的. 而将 @Reusable 用于不可变对象则是很安全的，如果你不关心它们会被调用多少次你可以不用作用域注解.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reusable</span> <span class="comment">// It doesn't matter how many scoopers we use, but don't waste them.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeScooper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> CoffeeScooper() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CashRegisterModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span></span><br><span class="line">  <span class="meta">@Reusable</span> <span class="comment">// DON'T DO THIS! You do care which register you put your cash in.</span></span><br><span class="line">            <span class="comment">// Use a specific scope instead.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> CashRegister <span class="title">badIdeaCashRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CashRegister();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="meta">@Reusable</span> <span class="comment">// DON'T DO THIS! You really do want a new filter each time, so this</span></span><br><span class="line">          <span class="comment">// should be unscoped.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeFilter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> CoffeeFilter() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="延迟注入-Lazy-injections"><a href="#延迟注入-Lazy-injections" class="headerlink" title="延迟注入 (Lazy injections)"></a>延迟注入 (Lazy injections)</h3><p>某些情况下需要延迟初始化一个对象. 对任意的对象 T 来说, 你可以通过创建一个 <a href="http://google.github.io/dagger/api/latest/dagger/Lazy.html" target="_blank" rel="external">Lazy&lt;T&gt;</a> 对象来实现延迟初始化. Lazy&lt;T&gt; 只有当 Lazy&lt;T&gt; 的 get() 方法被调用时， 才会初始化 T 对象. 如果 T 是个单例对象，Lazy&lt;T&gt; 也将使用同一个对象进行注入操作. 否则，每次注入都将生成自己的Lazy&lt;T&gt; 对象. 无论随后调用任何方法获取 Lazy&lt;T&gt; 实例都将返回之前构建好的 T 对象，不会再创建新的对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GridingCoffeeMaker</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> Lazy&lt;Grinder&gt; lazyGrinder;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (needsGrinding()) &#123;</span><br><span class="line">      <span class="comment">// Grinder created once on first call to .get() and cached.</span></span><br><span class="line">      lazyGrinder.get().grind();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提供者注入-Provider-injections"><a href="#提供者注入-Provider-injections" class="headerlink" title="提供者注入 (Provider injections)"></a>提供者注入 (Provider injections)</h3><p>有些情况下， 你需要多个对象实例， 而不是仅仅注入一个对象实例. 你有几种实现方式 (Factories, Builders, etc.)，其中一种是利用 <a href="http://docs.oracle.com/javaee/7/api/javax/inject/Provider.html" target="_blank" rel="external">Provider&lt;T&gt;</a> 来实现，每次调用 Provider&lt;T&gt; 的 get() 方法将返回新的 T 的对象实例. 如果是通过 @Inject 注解构造方法，将会创建一个新的实例，但如果是 @Provides 注解方法就不能保证了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigCoffeeMaker</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> Provider&lt;Filter&gt; filterProvider;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">(<span class="keyword">int</span> numberOfPots)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; numberOfPots; p++) &#123;</span><br><span class="line">      maker.addFilter(filterProvider.get()); <span class="comment">//new filter every time.</span></span><br><span class="line">      maker.addCoffee(...);</span><br><span class="line">      maker.percolate();</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>注意</em>：注入 Provider&lt;T&gt; 可能导致代码结构混乱或者作用域注解设计混乱以及对象图结构出错. 通常来说你最好还是用 <a href="https://en.wikipedia.org/wiki/Factory_%28object-oriented_programming%29" target="_blank" rel="external">factory</a> 或是  Lazy&lt;T&gt; 或者重新组织一下代码的生命周期和结构，做到只注入一个 T 对象就能解决问题. 尽管注入  Provider&lt;T&gt; 在某些情况下是很有用的. 一种常用的用法就是当你必须要使用一个陈旧的架构，而这个架构又无法与你的对象的正常生命周期想一致 (比如：servlets 被设计为单例，但是只有是请求特定的数据的 context 才有效).</p>
</blockquote>
<h3 id="限定符-Qualifiers"><a href="#限定符-Qualifiers" class="headerlink" title="限定符 (Qualifiers)"></a>限定符 (Qualifiers)</h3><p>有些时候，单一类型是不能够满足指定依赖的需求的. 例如，一个复杂的 Coffee maker 程序可能需要不同的加热器 (separate heaters for the water and the hot plate).</p>
<p>在这种情况下，我们可以添加<strong>限定符注解</strong>. 这种注解本身就需要一个 <a href="http://docs.oracle.com/javaee/7/api/javax/inject/Qualifier.html" target="_blank" rel="external">@Qualifier</a> 注解. 下面是 javax.inject 中 <a href="http://docs.oracle.com/javaee/7/api/javax/inject/Named.html" target="_blank" rel="external">@Named</a> 的声明代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Named &#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以创建自己的限定符注解或者使用默认的 @Named . 限定符可以用来注解域或需要的参数. 这些限定符注解将与类型一起用来标记依赖关系.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpensiveCoffeeMaker</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> <span class="meta">@Named</span>(<span class="string">"water"</span>) Heater waterHeater;</span><br><span class="line">  <span class="meta">@Inject</span> <span class="meta">@Named</span>(<span class="string">"hot plate"</span>) Heater hotPlateHeater;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供限定符注解的值来注解相应的 @Providers 方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span> <span class="meta">@Named</span>(<span class="string">"hot plate"</span>) <span class="function"><span class="keyword">static</span> Heater <span class="title">provideHotPlateHeater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ElectricHeater(<span class="number">70</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Provides</span> <span class="meta">@Named</span>(<span class="string">"water"</span>) <span class="function"><span class="keyword">static</span> Heater <span class="title">provideWaterHeater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ElectricHeater(<span class="number">93</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能同时使用多个限定符注解.</p>
<h3 id="编译时有效性的检查-Compile-time-Validation"><a href="#编译时有效性的检查-Compile-time-Validation" class="headerlink" title="编译时有效性的检查 (Compile-time Validation)"></a>编译时有效性的检查 (Compile-time Validation)</h3><p>Dagger 包含一个 <a href="http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/package-summary.html" target="_blank" rel="external">annotation processor</a> ， 这个注解处理器非常严格， 若是有任何绑定是无效或者不完整的， 将引发编译错误。例如， 这个 Module 被设置到一个 component 时，缺少 <code>Executor</code> 的对象绑定:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DripCoffeeModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Provides</span> <span class="function"><span class="keyword">static</span> Heater <span class="title">provideHeater</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CpuHeater(executor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时， <code>javac</code> 将提示缺少对象绑定:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] COMPILATION ERROR :</span><br><span class="line">[ERROR] error: java.util.concurrent.Executor cannot be provided without an @Provides-annotated method.</span><br></pre></td></tr></table></figure>
<p>为了修正这个错误， 可以添加 Executor 的 @Provides 方法到一个被设置到该component 的 Module. @Inject, @Module 和 @Provides 注解的验证是逐个进行的, 所有绑定关系的验证都发生在 @Component 层. Dagger 1 依赖于严格的 @Module-level 校验 (可能会在 runtime 用到反射来实现), Dagger 2 则无需这步校验 (而是通过配置 @Module 的参数) 用完整的图校验来代替.</p>
<h3 id="编译时生成代码-Compile-time-Code-Generation"><a href="#编译时生成代码-Compile-time-Code-Generation" class="headerlink" title="编译时生成代码 (Compile-time Code Generation)"></a>编译时生成代码 (Compile-time Code Generation)</h3><p>Dagger 的注解处理器可以生成源码文件，它们的命名类似 <code>CoffeeMaker_Factory.java</code> 或 <code>CoffeeMaker_MembersInjector.java</code>. 这些文件是 Dagger 的实现细节. 我们不需要直接使用，在单步调试的时候我们可以查看到这些代码. 你只需要查阅自动生成代码中那些以 Dagger 为前缀的 component 实现类.</p>
<h2 id="使用-Dagger-构建你的项目-Using-Dagger-In-Your-Build"><a href="#使用-Dagger-构建你的项目-Using-Dagger-In-Your-Build" class="headerlink" title="使用 Dagger 构建你的项目 (Using Dagger In Your Build)"></a>使用 Dagger 构建你的项目 (Using Dagger In Your Build)</h2><h3 id="Gradle-用户-Gradle-Users"><a href="#Gradle-用户-Gradle-Users" class="headerlink" title="Gradle 用户 (Gradle Users)"></a>Gradle 用户 (Gradle Users)</h3><p>你需要添加 <code>dagger-2.2.jar</code> jar 包到你应用的 <code>runtime</code> . 为了能让 Dagger 帮你自动生成代码，你需要添加 <code>dagger-compiler-2.2.jar</code> jar 包到你 compile time 的构建中.</p>
<p>在 Maven 项目中, 你的 <code>pom.xml</code> 文件其中一部分依赖会在 <code>runtime</code> 的时候被添加进来，<code>dagger-compiler</code> 部分被作为编译插件的依赖:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.dagger<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dagger<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.dagger<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dagger-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="许可证-License"><a href="#许可证-License" class="headerlink" title="许可证 (License)"></a>许可证 (License)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copyright 2014 Google, Inc.</span><br><span class="line">Copyright 2012 Square, Inc.</span><br><span class="line"></span><br><span class="line">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line">you may not use this file except in compliance with the License.</span><br><span class="line">You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">   http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">Unless required by applicable law or agreed to in writing, software</span><br><span class="line">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">See the License for the specific language governing permissions and</span><br><span class="line">limitations under the License.</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
